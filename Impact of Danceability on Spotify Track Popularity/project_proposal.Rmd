---
title: "Lab 2 Data Proposal"
author: "Saniya Lakka, Megan Martin, Andrew Sandico"

output:
  pdf_document: default
  html_document: default
  fig_width: 6 
  fig_height: 4 
---
**Introduction**: 

As part of the data scientist team for Acme, Inc, we are supporting the product Spotify to maximize the number of streams by identifying the key audio feature that causes the amount of streams. Since Spotify monetizes by usage (how many times a song is played and how long a user stays on the app), our work is motivated to identify the Spotify feature that causes the most streams.   

**Approach**:

To operationalize our work, we will be leveraging (or creating) a data set from Spotify that identifies audio features for songs.  Our conceptual model that explains the causation of more streams is that the specific audio feature of danceability would have the largest R2 to predict number of streams.

![](flow.png){width=50%}

Short Model :  Streams = B1 danceability + u

Danceability as defined by spotify: Danceability describes how suitable a track is for dancing based on a combination of musical elements including tempo, rhythm stability, beat strength, and overall regularity. A value of 0.0 is least danceable and 1.0 is most danceable.

Control variables: genre, accousticness, energy, instrumentalness, liveness, loudness, mode, speechiness, tempo, and valence. 

Spotify provides a description of these music features here: https://developer.spotify.com/documentation/web-api/reference/#/operations/get-audio-features 

Categorical variables to include: artist, genre 


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load packages, message = FALSE, include=FALSE}
library(tidyverse)
library(patchwork)
library(stargazer)
library(sandwich)
library(lmtest)
library(dplyr)
library(tidyr)
library(stringr)
```

```{r read datafile, include=FALSE}
#Datafile obtained from: https://www.kaggle.com/datasets/yujisato/spotify-us-weekly-top200 
#Spotify Weekly Top200 Songs in the US (2017-2021)
spotify_top_streams <- read.csv(file = 'spotify_us_weekly_top200.csv')
head(spotify_top_streams)
dim(spotify_top_streams)
class(spotify_top_streams)
dim(spotify_top_streams)
```
```{r parse unique track ID for future dataset join, include=FALSE}
test_spotify_top_streams <- spotify_top_streams
test_spotify_top_streams <- test_spotify_top_streams %>%
  separate(URL, c('URL', 'drop_1', 'drop_2', 'drop_3', 'drop_4', 'id'))
spotify_top_streams_tracks <- subset(test_spotify_top_streams, select = -c(URL, drop_1, drop_2, drop_3, drop_4))
head(spotify_top_streams_tracks)
#have to add up the streams across id, then retain the top entry, will represent a top daily stream column and a total stream column 
```
```{r, include=FALSE}
streams_histogram <- test_spotify_top_streams %>% 
  ggplot() +  
  aes(x = log10(Streams)) + 
  geom_histogram(bins = 150) + 
  labs(
    x = 'streams', 
    y = 'Count', 
    title = 'Histogram of streams'
  )
streams_histogram
```


```{r pull unique track ID for future dataset join, include=FALSE}
 test_df <- test_spotify_top_streams %>% 
    group_by(id) %>% 
    filter(Streams == max(Streams))
head(test_df)
length(unique(test_df$id))
```
```{r, include=FALSE}
streams_histogram_2 <- test_df %>% 
  ggplot() +  
  aes(x = log10(Streams)) + 
  geom_histogram(bins = 100) + 
  labs(
    x = 'streams', 
    y = 'Count', 
    title = 'Histogram of streams'
  )
streams_histogram_2
```
```{r, include=FALSE}
#https://www.kaggle.com/datasets/nadintamer/top-spotify-tracks-of-2018
spotify_top_2018_attributes <- read.csv(file = 'top2018.csv')
head(spotify_top_2018_attributes)
```
```{r, include=FALSE}
test_3 <- inner_join(test_df,spotify_top_2018_attributes,by = "id")
dim(test_3)
head(test_3)
```
```{r, include=FALSE}
spotify_top_streams[which(spotify_top_streams$Track.Name == "6DCZcSspjsKoFjzjrWoCd!"), ]
```
```{r, include=FALSE}
#For the original weekly top 200 dataset, sum for total streams over time period (2017-2021) by song id.
sum_stream_df <- test_spotify_top_streams %>%
  group_by(id) %>%
  mutate(
    sum_streams = sum(Streams),
    )
head(sum_stream_df)
dim(sum_stream_df)
```

```{r, include=FALSE}
head(spotify_top_2018_attributes)
```

```{r, include=FALSE}
sum_stream_combined_top2018 <- inner_join(spotify_top_2018_attributes, sum_stream_df, by=c("name" = "Track.Name", "artists" = "Artist"))
dim(sum_stream_combined_top2018)
head(sum_stream_combined_top2018)
```
```{r, include=FALSE}
 test_df_2 <- sum_stream_combined_top2018 %>% 
    group_by(name, artists) %>% 
    filter(Streams == max(Streams))
head(test_df_2)
length(unique(test_df_2$id.y))
dim(test_df_2)
```

```{r, include=FALSE}
#https://www.kaggle.com/datasets/geomack/spotifyclassification
spotify_2017_attributes <- read.csv(file = '2017_song_attributes.csv')
head(spotify_2017_attributes)
```
```{r,include=FALSE}
sum_stream_combined_2017 <- inner_join(spotify_2017_attributes, sum_stream_df, by=c("song_title" = "Track.Name", "artist" = "Artist"))
dim(sum_stream_combined_2017)
head(sum_stream_combined_2017)
```

```{r filter dataset to include only one entry per song, include=FALSE}
 final_combined_2017 <- sum_stream_combined_2017 %>% 
    group_by(song_title, artist) %>% 
    filter(Streams == max(Streams))
head(final_combined_2017)
length(unique(final_combined_2017$id))
dim(final_combined_2017)
```

```{r determine the repeated song ids in the final dataset, include=FALSE}
#Note that there may be differences between song name, artist name combination between the two datasets. 
repeated_ids <- data.frame(table(final_combined_2017$id))
repeated_ids[repeated_ids$Freq > 1,]
dim(repeated_ids)
#there are 3 repeated ids, these should be removed at a later date. 
```
```{r, include=FALSE}
#Remove unnecessary rows from final dataset: 
final_combined_2017 <- subset(final_combined_2017, select = -c(X, Position, URL, drop_1, drop_2, drop_3, drop_4))
```

**Initial Data Exploration:**

We combined two datasets for this proof of concept. The first dataset contains attributes of songs from 2017 and was obtained from [here](https://www.kaggle.com/datasets/geomack/spotifyclassification). The second dataset contained streaming counts for the top 200 songs by week from 2010-2017 and was obtained from [here](https://www.kaggle.com/datasets/yujisato/spotify-us-weekly-top200). Because the song streaming dataset contained weekly streaming numbers, the dataset was collapsed by song to provide a total streaming count by song. Finally, the streaming count dataset was joined with the song attribute dataset. The final dataset contains 118 songs from 2017 with streaming totals and music attributes for which this analysis can be conducted. The column names are listed below: 


```{r, echo = FALSE}
#Use this for proposal RMD: 
#dim(final_combined_2017)
colnames(final_combined_2017)
```

Plotting the log transformation of the total streams provides the following distribution: 


```{r, histogram of streams in final dataset, echo = FALSE}
streams_histogram_final <- final_combined_2017 %>% 
  ggplot() +  
  aes(x = log10(sum_streams)) + 
  geom_histogram(bins =30) + 
  labs(
    x = 'log streams', 
    y = 'Count', 
    title = 'Histogram of Number of Streams'
  )
streams_histogram_final
```


Finally, plotting our proposed primary feature (danceability) by total streams provides the following distribution: 

```{r scatterplot of danceability vs streams, echo = FALSE}
scatter_danceability_streams <- final_combined_2017 %>%
  ggplot(aes(x = danceability, y = log10(sum_streams))) +
  geom_point() + 
  labs(
    title = "Relationship Between Danceability Score and Streams",
    x = "Danceability score",
    y = "Total number of streams"
  )
scatter_danceability_streams

```

After approval of this dataset, we will attempt to pull attribute data for songs directly from the spotify using the API. 
